# Operating System From 0 to 1

## 序言

​		你看到这本书的时候或许原著已经更新完，或者还没有。先不要因为原著没更新完的一点可能打消积极性：这本书目前更新到的位置足够你掌握一项本领：自学。去自己解决问题，自己阅读官方文档等等。换句话说，这本”残书“实际上已经是完成了它最重要的使命；

​		原著在`GitHub`上开源，但是是全英文。所以我为了方便自己归纳知识或者方便外语基础相对薄弱一点的朋友了解这本书，斗胆为这本书重点做归纳。

​		整个开源项目的宗旨是：*What I cannot create, I do not understand — Richard Feynman.* 

​		所以这本书与经典书籍就有了不同的侧重点，这本书在让我们完成一个操作系统。从而对操作系统有更深的理解，至少会有以下收获：

* 将学习到计算机是怎样在硬件层面工作，以及学习编写软件直接控制硬件相关知识
* 将学习到操作系统的基础，让你适应任何操作系统，而不局限于Linux
* 为了深层次的了解Linux系统，你需要袭击写一个简单的系统
* 将打开底层编程领域的大门：构建虚拟机、逆向工程技术等
* Writing an operating system is fun!

##### 为什么还要写一本操作系统的书？

​    	市面上已经存在很多由享誉全球的专家写的书或者讲的公开课。是不是就没必要写这本书？本书作者发现了这些经典书籍都共同缺少了一些东西：**很少有讲到如何编译你自己的程序或者独立于操作系统的C运行库；很多相关的经典书籍侧重于软件层面去讲解操作系统的实现；而硬件是如何与操作系统交互的却很少提到；重要的硬件细节也被忽视；**更为凑巧的是对于自学者又很难找到相关的资料去学习，就导致学习过程似乎一直难以落地。

​		而这本书就是为了弥补这一点缺憾，你不仅会学会如何直接对硬件编程，还会学到如何阅读官方文档；不再需要找资料帮助自己解读官方文档，你可以独立完成这件事；帮助你将更多的时间花在学习上，而不是无依据的猜测或者找资料上

##### 知识储备：

* 电路的基本知识
* C语言编程：
* * 变量和函数的生命和定义
  * while以及for循环
  * 指针和函数指针
  * 基本的算法和数据结构
* Linux基本操作
* * 用命令行浏览目录等
  * 会用命令的参数
  * 利用管道命令将一个命令的输出作为下一个命令的输入
* 盲打



##### 大体内容

###### 第一部分

* 第一章：域文档`domin documents`的重要性
* 第二章：从硬件到软件解释操作系统抽象层次；为了使读者明白代码是如何在实物上运行的
* 第三章：介绍通常的计算机架构，然后介绍一种简单的计算机模型，我们可以通过这个来自己写操作系统
* 第四章：使用Intel的手册介绍`x86`汇编语言，这章节将详细讲解高级语言和低级汇编语言之间的配合与联系。轻松的阅读生成的汇编代码
* 第五章：对ELF进行了详细的剖析。只有在二进制级别上理解程序的结构，才能构建在裸机上运行的程序。
* 第六章：用大量的案例来介绍`gdb`调试工具，了解到调试工具是如何工作的

###### 第二部分

* 第七章：介绍什么是`bootloader`，以及如何用汇编写一个`bootloader`以及如何把它装载到虚拟机上
* 第八章：通过解释合并object文件时的重定位过程来介绍链接。



## PART 1

### SECTION 1

#### 问题域（Problem Domains）

​		在现实世界中软件工程师不仅仅需要对软件编程层面精通，还要对需要解决的问题所在的领域有所了解

​		*A problem domain is the part of the world where the computer is to produce effects, together with the means available to produce them, directly or indirectly.  ( `Kovitz , 1999`)*

​    	问题域是软件相关的问题之外的问题，我们必须要搞明白才能解决用户需求的问题；比如我们要写一个理财类的APP，我们必须要懂理财的一些规则和一些基本操作,需要学习大量的经济层面的知识才能理解客户的需求。

​		编程本身并不是太复杂的；用软件相关知识解决其它领域的问题才是问题的关键；或许一个编程思想在这个领域使用但是在另一个问题上就很尴尬；比如这本书的主要工作：写一个操作系统。这件事需要有一定量的`EE（Electrical Engineering）`知识；如果一个`CS(Computer Science)`课程不包括相关的`EE`知识，那么这个`CS`学生基本不可能实现一个可以工作的操作系统的；如果他们实现了一个相关的项目：要么花了大量时间学习`EE`相关知识，要么就是使用一个预定义的框架（大概率不是自己的成果），只是填充了一些代码，只去理解高级语言里面的算法。对于EE学生只需要理解一些CS核心课程即可；一个简单的例子是一个擅长英语的人不一定擅长阅读英文编著的数学书；

​		如果一个程序员写程序为了谋生，最好**掌握一两个问题域**，减小被其他问题域学习编程的专家取代。

​		

#### 实现问题域的文档（官方手册或者官方文档）

官方文档对于学习一个问题域是很重要的。

没有官方文档：

* 新人会发现很难加入一个工程
* 一个项目很难执行下去，因为成员经常忽略一些重要的、未解决的bugs 和 quirks
* 对于的用户来说很难理解没有官方文档的产品。

##### 软件官方文档（Software Requirement Document）

​		*Software requirement document includes both a list of requirements and a description of the domain （Kovitz ，1999）*

​		软件具体解决什么问题是由用户提出来的。所有这些需求列一张表格，软件工程师需要完成的目标就是这一系列的要求。大部分的软件设计和应用都取决于问题域的知识，对问题域的理解越深刻，做出的软件质量就越高；比如，建造一个房子经历了超过几千年的历史被很好的理解和掌握，因此建造一个高质量的房子是很简单的；软件领域也一样，代码难以理解的原因归咎于作者对问题域的忽略；在这本书的后续内容里我们将去理解硬件底层工作原理；

​		通常没有一对一的映射，打个比方，一个普通的电脑用户认为他的电脑操作系统是通过GUI运行一些程序，或者一些游戏。但是对于这种需求，操作系统需要分为多层次去实现这样一个功能，每一层对上一层透明（提供接口但是不提供内部细节）；制作一个操作系统，需要不同领域的各种知识，尤其是运行在一些非个人电脑设备上时；

##### 软件规范说明（Software Specification）

​	*Software specification document states rules relating desired behavior of Software specification the output devices to all possible behavior of the input devices, as well as any rules that other parts of the problem domain must obey .Kovitz  (1999)*

​		简单的说，软件规范是人机交互的接口设计，通过加入一些问题域需要遵循的限制：比如软件只可以接受某种输入，例如英语（意思就是其他语言识别不了）；对于硬件来说，软件规范说明书是需要的，因为软件要遵循硬件的逻辑行为；事实上也确实如此，硬件的规范说明包含了很细微的细节，做的很细致；这样做是必要的，因为如果硬件需要人来做，没有改错的机会（错一处可能就要重新再来），如果有缺陷，那么对于公司声誉和财政来说是致命的；

​		既然与官方文档类似，软件规范只需要注意交互接口的设计，如果加入实现的细节，将会对现实的实现与规范文档的同步增加不少负担，这样将来会被淘汰。

​		另一个重要的说法是：尽管规范说明文档很重要，但是并不需要它一定要在产品实现之前生产出来，不管什么时候和什么方法，只要在最后做出一个完整的规范说明就可以；

​		

#### 写`x86`操作系统的文档(Documents for writing an `x86`  OS)

​		当问题域和软件软件领域（CS内容）不同的时候，需求文档和规范文档一般是分开的。如果问题域包含在软件领域内，那么这两个文档就可以合二为一。前面提到了文档的重要性，要实现一个操作系统，我们需要收集相关的文档去获得大量的领域知识：

* `Intel®64 and IA-32 Architectures Software Developer’s Manual (Volume 1, 2, 3）`
* `Intel®3 Series Express Chipset Family Datasheet`
* `System V Application Binary Interface`

​		与需求文档对应的是`Functional Description`；与规格文档对应的是：`Register Description`

​		 

### SECTION 2 (抽象层面从硬件层面到软件层面)

这一章节将重点涉及硬件与软件是如何链接到一起的

#### 一个比特位的物理实现（The physical implement of a bit）

​		所有的电子设备，从简单到复杂都是操控电流在真实的物理世界中去达到想要的结果。当我们写软件的时候我们间接地在物理层面操作电流，在这种方式下，机器就潜在的产生了预期地结果。为了理解这个过程，我们想象一个灯泡，借助开关可以有有两种状态：开和关；打开时用1表示，关闭时用0表示；

​		但是有一个问题是这个类比中需要认为的干预（打开开关或者闭合开关），我们现在需要的是一个基于电压变化的开关。**三极管**就可以完成这个工作； 三极管的产生开启了计算机行业的大门。

​		一个晶体管就是一个电阻，其阻值可以根据输入电压变化。根据这个特性，晶体管可以被用作一个电流放大器（增大电压、减小电阻）或者一个根据电压值的控制电流的开关。当电压为0伏的时候，没有电流可以通过，因为现在的阻值完全可以阻止电流的通过；类似的，如果电压在3.5伏，电流就可以通过，因为阻值减小了。

​		一个比特位有两种状态：0和1，这是所有电子系统和软件最基本的构成。类似于一个灯泡可以开关，比特位比特位是由来自电源的电流构成的Bit 0 意味着0 V ，Bit 1 代表着+3.5 V到+5 V，晶体三极管确实可以很好的实现一个比特位，因为他可以根据电压大小调节控制电流。

##### MOS管（`MOSFET transistor`）

​		传统的经典晶体三极管的发明打开了微型数字设备全新的大门。在此之前，用一种真空的发光管（更为花哨的灯泡）表示0和1，并且需要人的干预（手动打开和关闭），MOS管是传统经典三极管的改进，更适合微型数字设备：在0和1之间切换时间更短，消耗更少的能量，并且更容易生产；

#### 逻辑门（`Beyond transistor：Digital logical gates`）

​		所有的数字设备都是由逻辑门组成的，本质上任何一个逻辑操作都是由逻辑门组合而成，也就是不同布尔函数的组合；

​		

##### 2.2.1 逻辑门的理论

​		逻辑门只允许二进制输入并且输出也是二进制数字，换句话说：逻辑门的作用是转化二进制数字；

​		这实际上就是数学的一个成熟分支----布尔代数。经过证明：`NOR`和`NAND`：或非门 与 与非门 可以组成任何逻辑函数，包括一些复杂运算。这就是晶体管、CMOS管对计算机革命性的意义；

##### 2.2.2逻辑门的实习：CMOS 电路

​		每个逻辑门的底层都是电路，当我们编程写软件的时候，我们就是在物理层面操控电流，以期得到预期的结果；但是整个过程又与电流的思想没有任何关系，这就是神奇的地方，马上会解释这一点。

​		CMOS一个有趣的特性是一个k输入的门电路由k个`PMOS`和k个`NMOS`晶体管组成，所有逻辑门都由成对的N、P MOS管构成，门电路是数字设备的最基本组成单位，包括计算机；也正因为这个特性，使得将逻辑单位与物理实现分开称为可能；数字设计是通过逻辑门实现的，然后编译称为物理电路；事实上我们看到的逻辑门是一种描述电路怎样运行的一种”语言“；    理解CMOS是如何工作的对于计算机的设计与工作原理是很重要的。

​		最后，由导线和晶体管组成的电路被物理地存储在一个称为芯片的封装中。芯片是刻蚀电路的基板。市场上称芯片就是完全封装的集成电路，不同情况下理解不同；

---

###### Example

​		`74HC100`是一个有四个两输入端的与非门，因此有八个输入端四个输出端。一个端口接电源一个接地，这是与非门的实际应用。芯片有四个可以组合的门，每个不和都可以实现不同的逻辑功能从而高效的创建其他逻辑门，这就是芯片占据主流的原因；

​		上面提到的每个门都是一个简单的与非门电路。但是许多这样的与非门芯片可以构成一个简单的计算机，软件在物理层面就是电流；

​		我们如何用`74HC00`芯片创建其他门电路？简单说是用一个芯片的输出作为下一个电路的输入

---

#### 逻辑门之外的机器语言（Beyond Logical Gates）

##### Machine Language

​		由于芯片是建立在门电路之上的，而门电路只能接受0和1的输入，因此一个硬件设备自然而然地也就只能识别0和1。机器语言是一系列特定比特位的位模式的集合，设备可以识别这种位模式并作出对应的操作；		指令集就是设备可以识别的特殊的位模式集合。在计算机系统中，有自己语言的设备叫CPU（Central Processing Unit），它控制着计算机内部的所有活动。如果这两段文字理解起来比较吃力，可以举个如下例子：

​		在`x86架构`的计算机中，位模式`10100000`就代表着告诉CPU执行加法的指令；可以理解为`10100000`就意味着加法。还有`000000101`对于计算机来讲就是暂停（halt）。在早些时候人们不得不全用二进制书写这一系列操作；

​		为什么这些二进制组合可以让设备去执行特定的命令呢？每个基本的指令的功能都是通过电路。这些二进制数类似于函数/子进程的名字，而这些位模式就是CPU里基本功能的名字，如果CPU发现这些位模式就会执行相应的功能操作；

​		CPU并不是唯一一个有自己语言的设备，CPU是一个控制计算机系统的设备的名称，一个硬件设备或许不是CPU但是也有自己的语言，有自己语言的设备叫做可编程设备。因此一个用户可以用设备相关的指令去让设备完成一些指令。比如：一个打印机有自己的指令集去让他打印一个页面；

​		功能描述提供了真值表，真值表中包括了所有可能的输入与输出，也对设备引脚的用法进行了描述。用户不需要知道硬件的实现，只需要知道这样一张真值表去使用设备；这张真值表就是这个设备的”语言“既然设备时数字化的。他的语言就是二进制字符串的集合：

* 设备有8个输入端，意味着它接受8位二进制数；
* 设备有4个输出引脚，这意味着它输出4位二进制字符串

​		<img src="C:\Users\17632\AppData\Roaming\Typora\typora-user-images\image-20220707113626806.png" alt="image-20220707113626806" style="zoom:50%;" />

​		

##### 汇编语言（Assembly Language）

​		汇编语言是二进制机器代码的符号表示，给位模式定义便于人理解和记忆的名字。这相对于必须用0和1写程序来说是一个巨大的进步；我们可以用`hlt`来代替`000000101`，只需要写`hlt`就可以让计算机停止运行，这样的抽象是的CPU执行的指令更易于记忆，因此可以有更多的指令被记忆之后就不用频繁翻阅手册去查找某个指令对应的位模式；

​		尽管在今天，理解汇编语言对底层变成来说是至关重要的。一个程序员想要理解越多的指令，就需要对机器架构的理解越深；

---

###### Example:

```assembly
or	<op1>, <op2>
nand	<op1>, <op2>
```

* or 的输入端是两个4位的操作数，这个对应`74HC00`芯片集成的或门
* nand 输入端是两个4位的操作数，对应`74HC00`芯片

 		到目前为止，我们仅仅指定输入和输出，并将其手动输入到设备，也就是执行一个操作。

​		执行一个操作：

* 亲自选取设备
* 手动向引脚输入信号

​		首先我们想让挑选设备的过程自动化。也就是说，我们希望简单的编写汇编语言然后实现的设备可以自动正确地被选择出来。解决这个问题是简单的：

* 给每个指令一个二进制索引，叫做操作数（`operation code`），并把它作为输入的一部分，每个操作数的数值就像下表中一样明确：

| Instruction | Binary Code |
| ----------- | ----------- |
| `nand`      | 00          |
| `or`        | 01          |



​		比如要进行两个数的与非运算

```assembly
nand  1100 , 1100
```

​		就可以等价为：00 1100 1100，前两位解码后是与非运算（以上表为例）。

* 额外添加一个设备基于指令的二进制代码去正确选择要使用的设备。

​		这样一种设备叫做译码器，CPU的一个重要组成部分。在上述的例子中，我们输入0011001100到译码器，由于操作数是`00`，所以数据将被送到`NAND`设备进行计算；

​		最后，书写汇编语言代码是写二进制字符串的简单形式；当我们书写汇编代码并且保存为文本文件的时候，一个叫做汇编器的程序将文本文件翻译为机器可以理解的二进制字符串；那么世界上第一个汇编器是怎么存在的呢？

​		假设这是世界上第一个汇编器，它是用二进制编写的。在它下一个版本中，工作就简单了：程序员可以用汇编语言写汇编器，然后用第一版去编译这个汇编代码，然后这些二进制字符串就被保存在另一个设备里，这个设备又可以检索二进制编码然后发送到译码器，存储设备就是一个电路阵列可以保存0和1，直观的来说就是可以用来存储机器级指令的设备。

​		解码器也是用逻辑门组成的，但是存储设备可以是任何可以存储0和1的设备，只要可以检索到并且取出数据，就可以作为存储设备。

<img src="F:\ayanlee\blog_file\gitlearn\learngit\Operating System From 0 to 1.assets\image-20220708110317297.png" alt="image-20220708110317297" style="zoom:50%;" />

​		
